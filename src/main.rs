use koopa::back::KoopaGenerator;
use koopa::ir::Program;
use lalrpop_util::lalrpop_mod;
use sysy_compiler::codegen;
use sysy_compiler::irgen;
use std::env::args;
use std::fs::read_to_string;
use std::io::Write;
use std::process::exit;
use std::{fmt, io, fs::File};
use std::result::Result;

// Include the parser generated by lalrpop
lalrpop_mod!(sysy);

fn main() {
  if let Err(err) = try_main() {
    eprintln!("{}", err);
    exit(-1);
  }
}

fn try_main() -> Result<(), Error> {
  // Parse Command Line Arguments
  let CommandLineArgs {
    mode,
    input,
    output,
  } = CommandLineArgs::parse()?;

  // Read input file
  let input = read_to_string(input)
    .map_err(Error::File)?;

  // Parse input file with the parser generated by lalrpop
  let comp_unit = sysy::CompUnitParser::new()
    .parse(&input)
    .map_err(|_| Error::Parse)?;

  // Generate Koopa IR
  let koopa_program = irgen::generate_koopa_program(&comp_unit)
    .map_err(Error::GenerateIr)?;

  // Generate output according to the mode [Koopa or Riscv]
  match mode {
    Mode::Koopa => print_koopa_ir(&koopa_program, &output)?,
    Mode::Riscv => print_riscv_asm(&koopa_program, &output)?,
  }

  Ok(())
}

fn print_koopa_ir(program: &Program, output_path: &String) -> Result<(), Error> { 
  let mut koopa_generator = KoopaGenerator::new(Vec::new());
  koopa_generator.generate_on(program)
    .map_err(|_| Error::Ir2Text)?;
  let koopa_ir_text = std::str::from_utf8(&koopa_generator.writer()).unwrap().to_string();

  let mut file = File::create(output_path)
    .map_err(Error::File)?;
  file.write(koopa_ir_text.as_bytes())
    .map_err(Error::Io)?;

  Ok(())
}

fn print_riscv_asm(program: &Program, output_path: &String) -> Result<(), Error> {
  let riscv_asm_text = codegen::generate_riscv(program)
    .map_err(Error::GenerateCode)?;

  let mut file = File::create(output_path)
    .map_err(Error::File)?;
  file.write(riscv_asm_text.as_bytes())
    .map_err(Error::Io)?;

  Ok(())
}

enum Error {
  InvalidArgs,
  File(io::Error),
  Parse,
  GenerateIr(irgen::IrgenError),
  Ir2Text,
  GenerateCode(codegen::CodegenError),
  Io(io::Error),
}

impl fmt::Display for Error {
  fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
    match self {
      Self::InvalidArgs => write!(
        f,
        r#"Usage: kira MODE INPUT -o OUTPUT

Options:
  MODE:   can be `-koopa`, `-riscv` or `-perf`
  INPUT:  the input SysY source file
  OUTPUT: the output file"#
      ),
      Self::File(err) => write!(f, "invalid file: {}", err),
      Self::Parse => write!(f, "error occurred while parsing"),
      Self::Io(err) => write!(f, "I/O error: {}", err),
      Self::GenerateIr(err) => write!(f, "error occured while generating IR: {}", err),
      Self::Ir2Text => write!(f, "error occured while converting IR to text"),
      Self::GenerateCode(err) => write!(f, "error occured while generating asm: {}", err),
    }
  }
}

struct CommandLineArgs {
  mode: Mode,
  input: String,
  output: String,
}

impl CommandLineArgs {
  fn parse() -> Result<Self, Error> {
    let mut args = args();
    args.next();
    match (args.next(), args.next(), args.next(), args.next()) {
      (Some(m), Some(input), Some(o), Some(output)) if o == "-o" => {
        let mode = match m.as_str() {
          "-koopa" => Mode::Koopa,
          "-riscv" => Mode::Riscv,
          _ => return Err(Error::InvalidArgs),
        };
        Ok(Self {
          mode,
          input,
          output,
        })
      }
      _ => Err(Error::InvalidArgs),
    }
  }
}

enum Mode {
  Koopa,
  Riscv,
}